Concepts and Terminology
========================

Understanding key concepts in Bansuri.

Core Concepts
-------------

Task
~~~~

A **task** is a single unit of work to be executed by Bansuri. Tasks can be:

- **Shell commands**: Simple bash/shell scripts
- **Python scripts**: Python files or modules
- **Custom implementations**: Classes inheriting from ``AbstractTask``

Each task has:

- Unique identifier (name)
- Command to execute
- Configuration for execution behavior
- Optional timeout and retry policies

Example task:

.. code-block:: json

    {
      "name": "backup-database",
      "command": "pg_dump production | gzip",
      "timer": "86400",
      "timeout": "2h"
    }

Orchestrator
~~~~~~~~~~~~

The **Orchestrator** is the central coordinator of Bansuri. It:

- Reads and parses configuration
- Spawns ``TaskRunner`` instances for each task
- Monitors task health and restarts
- Coordinates task lifecycle
- Synchronizes configuration changes

The Orchestrator runs continuously and manages all tasks in a single process.

TaskRunner
~~~~~~~~~~

A **TaskRunner** is responsible for managing the execution of a single task. Each task gets its own ``TaskRunner`` instance that:

- Runs in a dedicated thread
- Spawns and manages the task process
- Handles timeouts
- Captures output
- Implements retry policies
- Sends notifications on failure

Execution Models
~~~~~~~~~~~~~~~~

Bansuri supports different execution models:

**One-shot Execution**

Task runs once:

.. code-block:: json

    {
      "name": "setup",
      "command": "init.sh"
    }

**Timer-based Execution**

Task runs at fixed intervals:

.. code-block:: json

    {
      "name": "monitor",
      "command": "check.sh",
      "timer": "300"
    }

**Cron-based Execution (NOT IMPLEMENTED)**

Task runs on cron schedule:

.. code-block:: json

    {
      "name": "nightly-job",
      "command": "backup.sh",
      "schedule-cron": "0 2 * * *"
    }

Configuration Hierarchy
-----------------------

**Global Configuration** (scripts.json root level)

.. code-block:: json

    {
      "version": "1.0",
      "notify_command": "mail ..."
    }

**Per-task Configuration** (scripts[].* level)

.. code-block:: json

    {
      "name": "task-name",
      "command": "...",
      "timer": "300",
      "timeout": "30s",
      "on-fail": "restart",
      ...
    }

Task Lifecycle
--------------

A task progresses through these states:

1. **PENDING**: Registered in config, waiting to run
2. **RUNNING**: Process spawned with active PID
3. **SUCCESS**: Completed with success code (default: 0)
4. **FAILED**: Exited with non-zero code
5. **TIMEOUT**: Killed due to exceeding timeout
6. **RESTARTING**: Retrying after failure (if on-fail=restart)
7. **STOPPED**: Removed from config or shutdown

State Transitions
~~~~~~~~~~~~~~~~~

.. code-block:: text

    PENDING
      ↓
    RUNNING → SUCCESS (end)
      ↓
    FAILED
      ↓
    on-fail=stop? → STOPPED (end)
          │
          ↓ on-fail=restart?
    RESTARTING
      ↓
    (back to RUNNING)

Failure Policies
----------------

**on-fail: "stop"** (default)

Task stops immediately on failure:

.. code-block:: text

    RUNNING → FAILED → STOPPED

**on-fail: "restart"**

Task restarts up to ``times`` attempts:

.. code-block:: text

    RUNNING → FAILED → RESTARTING → RUNNING → FAILED → ... (up to 'times')
    
    If max attempts reached:
    FAILED → STOPPED

Example:

.. code-block:: json

    {
      "on-fail": "restart",
      "times": 3
    }

Timeout Behavior
~~~~~~~~~~~~~~~~

When timeout is exceeded:

.. code-block:: text

    RUNNING → (timeout reached) → FAILED → (apply on-fail policy)

The process is forcefully terminated with SIGKILL.

Success Codes
~~~~~~~~~~~~~

By default, only exit code ``0`` is considered success. You can define custom success codes:

.. code-block:: json

    {
      "success-codes": [0, 2, 137]
    }

Exit codes not in this list are considered failures.

Output Management
-----------------

Bansuri redirects task output according to configuration:

**No redirection**

Output goes to console (Bansuri's stdout/stderr):

.. code-block:: json

    {}
```

**File redirection**

.. code-block:: json

    {
      "stdout": "/var/log/task.log",
      "stderr": "combined"
    }

**Separate files**

.. code-block:: json

    {
      "stdout": "/var/log/task.out",
      "stderr": "/var/log/task.err"
    }

**Combined output**

Both stdout and stderr go to the same file:

.. code-block:: json

    {
      "stderr": "combined"
    }

Resource Management
-------------------

**Working Directory**

Tasks execute in the specified directory. Affects:

- Relative paths in commands
- File operations
- Working directory of child processes

**Timeout**

Maximum time a task can run. Process killed if exceeded.

Units:
- Seconds: ``"30"`` or ``30``
- Seconds suffix: ``"30s"``
- Minutes: ``"5m"`` = 300 seconds
- Hours: ``"2h"`` = 7200 seconds

**Process Groups**

Each task runs in its own process group. Allows:

- Killing task and all children
- Resource isolation
- Clean shutdown

Notification System
-------------------

Triggered on task failure when ``notify: "mail"`` is set.

Components:

- **FailureInfo**: Data structure with failure details
- **Notifier**: Abstract base class for notification handlers
- **CommandNotifier**: Sends notification via shell command

Failure notification includes:

- Task name and command
- Return code and exit details
- Attempt number
- Timestamp
- Stdout/stderr output
- Task description

See :doc:`notifications` for details.

Abstract Tasks
--------------

Custom task implementations implement the ``AbstractTask`` interface:

.. code-block:: python

    class AbstractTask(ABC):
        @abstractmethod
        def run(self) -> int:
            """Execute task, return exit code"""
            pass
        
        @abstractmethod
        def stop(self) -> None:
            """Stop task if running"""
            pass

Benefits:

- Complex business logic
- Native Python integration
- Stateful operations
- Resource cleanup

See :doc:`custom-tasks` for examples.

Configuration Management
------------------------

**Loading**

Configuration loaded from ``scripts.json`` when Bansuri starts:

1. Parse JSON file
2. Validate schema
3. Create ``BansuriConfig`` object
4. Spawn ``TaskRunner`` for each script

**Validation**

Each script is validated for:

- Required fields (name, command)
- Valid field types
- Sensible values
- Scheduling requirements

**Synchronization**

Bansuri periodically syncs config changes:

1. Detect added tasks → spawn ``TaskRunner``
2. Detect removed tasks → stop and remove ``TaskRunner``
3. Detect modified tasks → restart ``TaskRunner``

Performance Concepts
--------------------

**Concurrency**

Each task runs in its own thread. Multiple tasks execute concurrently.

**I/O-bound tasks** (network, disk):
- Can run many concurrently
- Limited by system I/O, not CPU

**CPU-bound tasks** (computation):
- Limited by CPU cores
- Too many concurrent = resource contention

**Resource Limits**

Monitor and limit:

- Memory: Each process and total system
- CPU: Per-process or total
- File descriptors
- Disk I/O

Observability Concepts
----------------------

**Logging**

Structured logging from:

- Orchestrator: Task lifecycle events
- TaskRunner: Execution events
- Tasks: Custom logs

**Monitoring**

Observable metrics:

- Task execution count
- Success/failure rates
- Execution time
- Resource usage
- Timeout occurrences

**Alerting**

Based on:

- Task failures
- Notification triggers
- System resource issues
- Configuration changes

Security Concepts
-----------------

**Process Isolation**

Each task runs in separate process with:

- Independent memory space
- Own file descriptors
- Own process group

**User Context**

(NOT IMPLEMENTED) Tasks can run as specific users with:

- Reduced privileges
- Different permissions
- Isolated home directories

**Working Directory**

Controls where tasks execute and what files they access.

**Permissions**

- Script execute permissions
- Log directory write permissions
- Output file creation permissions

High Availability Concepts
---------------------------

**Restart Policies**

Automatic recovery from failures:

- ``on-fail: "restart"``
- ``times: N`` attempts
- Configurable retry behavior

**Health Checks**

Monitor task execution:

- Track exit codes
- Detect hangs
- Measure latency

**Graceful Shutdown**

Clean termination:

1. Send SIGTERM to tasks
2. Wait for graceful shutdown
3. Force SIGKILL if needed
4. Flush logs and state

Scaling Concepts
----------------

**Single Instance**

Suitable for:

- < 100 tasks
- < 1000 executions/minute
- Single machine
- Non-critical workloads

**Multiple Instances**

For larger deployments:

- Partition tasks across instances
- Share configuration via version control
- Centralize logging
- Coordinate via monitoring

**Containerized Deployment**

Run in:

- Docker containers
- Kubernetes pods
- Cloud container services

Benefits:

- Reproducible environment
- Easy scaling
- Simplified deployment
- Resource limits

Related Concepts
----------------

**Cron** (traditional Linux scheduling)

Similar to Bansuri's timer-based execution but:

- System-level scheduler
- Separate from process lifecycle
- Limited monitoring

Bansuri advantages:

- Process-level control
- In-memory state
- Unified logging
- Flexible retry logic

**Process Managers** (supervisord, systemd)

Similar in goal but different scope:

- Process managers: Keep services running
- Bansuri: Orchestrate task execution

Bansuri can run under process managers for higher availability.

Terminology Reference
---------------------

===================  ===========================================================
Term                 Definition
===================  ===========================================================
Orchestrator         Central coordinator managing all tasks
TaskRunner           Thread-based executor for a single task
Task                 Unit of work to be executed
Script               Configuration entry for a task
Configuration        JSON file defining tasks and behavior
Exit Code            Process return value (0=success, non-zero=failure)
Timeout              Maximum execution time for a task
Failure Policy       What to do when task fails (stop or restart)
Notification         Alert sent when task fails
FailureInfo          Data structure with task failure details
Process Group        Group of processes from same task
Working Directory    Directory where task executes
Success Codes        Exit codes considered successful
===================  ===========================================================
